---
  
output: 
    html_document:
        highlight: default
        theme: paper
        code_folding: hide
        df_print: tibble
        toc: true
        toc_depth: 3
        toc_float: true
        css: src/assets/style/style.css

---
  
  
  
```{r setup_mon, include=FALSE}
knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 120),
  message = FALSE,
  warning = FALSE
)
```


```{r hpc_notes_mon, include=FALSE}

## Get interactive session ##
#  srun --time=08:00:00 --mem=40G -p int --pty bash

# module purge;source /camp/stp/babs/working/software/modulepath_new_software_tree_2018-08-13;module load pandoc/2.2.3.2-foss-2016b;ml R/3.6.0-foss-2016b-BABS;R;

# sbatch --time=12:00:00 --wrap "module purge;source /camp/stp/babs/working/software/modulepath_new_software_tree_2018-08-13;module load pandoc/2.2.3.2-foss-2016b;ml R/3.6.0-foss-2016b-BABS;Rscript runA.r" --job-name="rA"  --mem=100G -o rA.slurm >> commands.txt

# sbatch --time=24:00:00 --wrap "module purge;source /camp/stp/babs/working/software/modulepath_new_software_tree_2018-08-13;module load pandoc/2.2.3.2-foss-2016b;ml R/3.6.0-foss-2016b-BABS;Rscript runDGE.r" --job-name="rDGE" -p hmem --mem=300G -o rDGE.slurm >> commands.txt

# --mem-per-cpu=14G -p hmem --pty bash

# list all conda environments
# conda env list

# conda activate R-monocle3
# R-version of the above: R 4.0.2

# Install DEseq2
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# 
# BiocManager::install("DESeq2")



```

```{r populate_meta_data_database_Mon, eval=TRUE, echo=F, results=F}
#Create the environment and load a suitable version of R, e.g. so:
VersionPdfExt <- paste0(".V", gsub("-", "", Sys.Date()), ".pdf")

if (dir.exists("/Volumes/babs/working/boeings/")){
  hpc.mount <- "/Volumes/babs/working/boeings/"
} else if (dir.exists("Y:/working/boeings/")){
  hpc.mount <- "Y:/working/boeings/"
} else if (dir.exists("/camp/stp/babs/working/boeings/")){
  hpc.mount <- "/camp/stp/babs/working/boeings/"
} else {
  hpc.mount <- ""
}


FN <- paste0(hpc.mount, "Projects/reference_data/documentation/BC.parameters.txt")
dbTable <- read.delim(
  FN, 
  sep = "\t",
  stringsAsFactors = F
)

db.pwd <- as.vector(dbTable[1,1])

figureCount <- 1

# Install DEseq2
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("DESeq2")

install.packages("devtools")
install.packages("gam")
install.packages('circlize')

if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
BiocManager::install("ComplexHeatmap")

devtools::install_github("decusInLabore/biologicSeqTools")
devtools::install_github("decusInLabore/biologicToolsSC")
library(Seurat)
library(biologicSeqTools)
library(biologicToolsSC)


# source("assets/R/SBwebtools.pckg.r")
# source("assets/R/scTools.r")
# 
# if (length(.libPaths()) > 2){
#     .libPaths(.libPaths()[2:3])
# }
## Create biologic Object for visualization ##

ObioFN <- paste0("../", list.files("..")[grep(".bioLOGIC.Robj", list.files(".."))])

load(ObioFN)

checkFile = paste0(
  Obio@parameterList$project_id,
  ".bioLOGIC.Robj"
)


Obio <- setMountingPoint(Obio)
Obio <- setAnalysisPaths(Obio)
Obio <- setCrickGenomeAndGeneNameTable(Obio)
Obio <- createAnalysisFolders(
  Obio
)
Obio <- setDataBaseParameters(Obio)

## Upload metadata table > p315_PCA
# Obio@parameterList$host <- "10.152.22.193"
# Obio@parameterList$db.user <- "boeingS"
# db.pwd <- "5+3f4nB040420"


ObioFN <- paste0("../", list.files("..")[grep(".Seurat.Robj", list.files(".."))])

load(ObioFN)

## Create url string
if (Obio@parameterList$host == "10.27.241.234"){
  urlString <- "biologic.thecrick.org"
} else {
  urlString <- "biologic.crick.ac.uk"
}

legendDotSize <- 5


shinyURL <- paste0(
  "https://shiny-bioinformatics.crick.ac.uk/shiny/boeings/",
  Obio@parameterList$project_id,
  "_app/"
)            


## Set file paths ##
baseFN <- paste0(
  Obio@parameterList$project_id, 
  ".trajectory.table.xlsx"
)


outPutFN <- paste0(
  Obio@parameterList$reportTableDir,
  baseFN
)


FNrel <- paste0("report_tables/", baseFN)


## Create table link string ##

tableLink <- paste0('<a href="https://',urlString,'/mdata/',Obio@parameterList$project_id, '/html/', FNrel,' target="_blank">here</a>')  

tableString <- paste0('An Excel table with the DGE results can be downloaded ',
                      tableLink
)
```

```{r monocle_tutorial, eval=TRUE, echo=F, results=F}

## Tutorial from the Trapnell lab
# https://github.com/cole-trapnell-lab/monocle-release/issues/388

# ### Re-dimension reduction for 3D rendering
# 
# if (Dim = "3D") {
#   
#   print ("Running UMAP 3D")
#   
#   seurat <- RunUMAP(object = seurat, reduction = "pca", dims = 1:20, n.components = 3)
#   
#   print("Clustering 3D")
#   
#   seurat <- FindNeighbors(object=seurat, dims=1:20)
#   seurat <- FindClusters(object=seurat, resolution=0.5)
#   seurat[[sprintf("ClusterNames_%.1f_%dPC", 0.5, 20)]] <- Idents(object = seurat)
#   
# }
# 

### Building the necessary parts for a basic cds

# part one, gene annotations






library(Seurat)
library(monocle3)
library(htmlwidgets)

seurat <- OsC

## remove cluster 5 ##
seurat <- subset(x = seurat, subset = seurat_clusters %in% c(0:6,8,9,11:13, 15,16) )

gene_annotation <- as.data.frame(rownames(seurat@reductions[["pca"]]@feature.loadings), row.names = rownames(seurat@reductions[["pca"]]@feature.loadings))
colnames(gene_annotation) <- "gene_short_name"

# part two, cell information

cell_metadata <- as.data.frame(seurat@assays[["RNA"]]@counts@Dimnames[[2]], row.names = seurat@assays[["RNA"]]@counts@Dimnames[[2]])
colnames(cell_metadata) <- "barcode"

# part three, counts sparse matrix

New_matrix <- seurat@assays[["RNA"]]@counts
New_matrix <- New_matrix[rownames(seurat@reductions[["pca"]]@feature.loadings), ]
expression_matrix <- New_matrix


### Construct the basic cds object

cds_from_seurat <- new_cell_data_set(expression_matrix,
                                     cell_metadata = cell_metadata,
                                     gene_metadata = gene_annotation)


### Construct and assign the made up partition 
###### I DO NOT ADVISE THIS

recreate.partition <- c(rep(1, length(cds_from_seurat@colData@rownames)))
names(recreate.partition) <- cds_from_seurat@colData@rownames
recreate.partition <- as.factor(recreate.partition)

cds_from_seurat@clusters@listData[["UMAP"]][["partitions"]] <- recreate.partition


### Assign the cluster info

list_cluster <- seurat@meta.data[[sprintf("seurat_clusters")]]
#list_cluster <- seurat@meta.data[[sprintf("ClusterNames_%s_%sPC", 0.5, 20)]]
names(list_cluster) <- seurat@assays[["RNA"]]@data@Dimnames[[2]]

cds_from_seurat@clusters@listData[["UMAP"]][["clusters"]] <- list_cluster


### Could be a space-holder, but essentially fills out louvain parameters

cds_from_seurat@clusters@listData[["UMAP"]][["louvain_res"]] <- "NA"


### Assign UMAP coordinate

## old commented out
# cds_from_seurat@reducedDims@listData[["UMAP"]] <- seurat@reductions[["umap"]]@cell.embeddings

# replaced with from https://github.com/satijalab/seurat/issues/1658
cds_from_seurat@int_colData@listData$reducedDims@listData[["UMAP"]] <- seurat@reductions[["umap"]]@cell.embeddings 

### Assign feature loading for downstream module analysis

cds_from_seurat@preprocess_aux$gene_loadings <- seurat@reductions[["pca"]]@feature.loadings


### Learn graph, this step usually takes a significant period of time for larger samples

print("Learning graph, which can take a while depends on the sample")

cds_from_seurat <- learn_graph(cds_from_seurat, use_partition = T)

plot_cells(cds_from_seurat)

####Here I chose to save the gene_metadata, rds, etc.`


###############################################################################
## Calculate pseudotime                                                      ##

get_earliest_principal_node <- function(cds, time_bin="PF"){
  cell_ids <- which(colData(cds)[, "time"] == time_bin)
  cell_ids <- colData(cds)$barcode
  closest_vertex <-
  cds@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex
  closest_vertex <- as.matrix(closest_vertex[colnames(cds), ])
  root_pr_nodes <-
  igraph::V(principal_graph(cds)[["UMAP"]])$name[as.numeric(names
  (which.max(table(closest_vertex[cell_ids,]))))]
  root_pr_nodes
}




## Set root cells - here polykeratin cluster ##
root_cells <- as.vector(
    OsC@meta.data[OsC@meta.data$seurat_clusters == 5,"cellID"]
)

closest_vertex <-
  cds_from_seurat@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex

root_pr_nodes <-
  igraph::V(principal_graph(cds_from_seurat)[["UMAP"]])$name[as.numeric(names
  (which.max(table(closest_vertex[root_cells,]))))]

cds_from_seurat <- order_cells(
    cds_from_seurat,
    root_pr_nodes=root_pr_nodes,
    #root_cells = root_cells
)

## Export Pseudotime to Seurat object ##
# Branch 1
# Clusters Polykeratins (5) > mTecDiff (12) > NEDC_I_NEUROD1 (1) > NEDC_II_NEUROD1 (4) > NEDC_III_SOX2 (2) > NEDC_IV_SOX2 (11)
branch1 <- c(5, 12, 1, 4, 2, 11)
# Branch 2
# Clusters Polykeratins (5) > cTecDiff (9) > cTECI (0) > cTECIII (6) > cTECII (3)
branch2 <- c(5, 9, 0, 6,3)
# 
# Branch 3
# Clusters Polykeratins (5) > mTecDiff (12) > mTec MYO (8)
branch3 <- c(5, 12, 8)

traj.coord<- cds_from_seurat@principal_graph_aux@listData[["UMAP"]][["pseudotime"]]
dfPseudo <- data.frame(cellID = names(traj.coord), Pseudotime_MC = traj.coord)

dfPseudo$cellID <- NULL

## Add to Seurat object ##
OsC <- biologicToolsSC::addDf2seuratMetaData(
    OsC, 
    dfPseudo
)

OsC@meta.data[is.na(OsC@meta.data)] <- 0

dfPseudoT2 <- OsC@meta.data[,c("cellID", "seurat_clusters", "Pseudotime_MC")]
dfPseudoT2[["Pseudotime_MC_Lineage_1"]] <- 0
dfPseudoT2[dfPseudoT2$seurat_clusters %in% branch1, "Pseudotime_MC_Lineage_1"] <- dfPseudoT2[dfPseudoT2$seurat_clusters %in% branch1, "Pseudotime_MC"]


dfPseudoT2[["Pseudotime_MC_Lineage_2"]] <- 0
dfPseudoT2[dfPseudoT2$seurat_clusters %in% branch2, "Pseudotime_MC_Lineage_2"] <- dfPseudoT2[dfPseudoT2$seurat_clusters %in% branch2, "Pseudotime_MC"]


dfPseudoT2[["Pseudotime_MC_Lineage_3"]] <- 0
dfPseudoT2[dfPseudoT2$seurat_clusters %in% branch3, "Pseudotime_MC_Lineage_3"] <- dfPseudoT2[dfPseudoT2$seurat_clusters %in% branch3, "Pseudotime_MC"]

dfPseudoT2$cellID <- NULL 
dfPseudoT2$seurat_clusters <- NULL 
dfPseudoT2$Pseudotime_MC <- NULL

OsC <- biologicToolsSC::addDf2seuratMetaData(
    OsC, 
    dfPseudoT2
)

OsC@meta.data[is.na(OsC@meta.data)] <- 0

save(OsC,
    file = paste0(
         Obio@parameterList$localWorkDir,
         Obio@parameterList$project_id,
        ".Seurat.Robj"
     )
)

## Create three pseudotime branches ##


## Done                                                                      ##
###############################################################################
pdf("../temp.monocle.pseudotime.test")

plot_cells(cds_from_seurat,
           color_cells_by = "pseudotime",
           label_cell_groups=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE,
           graph_label_size=1.5)

dev.off()



###############################################################################
## Make Pseudotime Heatmaps                                                  ##

createLineageHeatmap <- function(
  OsC,  
  lineageSelection,
  pseudotimeLineageName = "Pseudotime_MC_Lineage_1",
  heatmapGeneVec = NULL,
  clusterRows = TRUE
){

OsC_branch1 <- subset(x = OsC, subset = seurat_clusters %in% lineageSelection )


if (is.null(heatmapGeneVec)){
    Y <- data.matrix( OsC_branch1@assays[["RNA"]]@data)
    
    Y <-  Y[OsC_branch1@assays$integrated@var.features,]
    
    t <- OsC_branch1@meta.data[,pseudotimeLineageName]
    
    # Fit GAM for each gene using pseudotime as independent variable.
    
    gam.pval <- apply(Y, 1, function(z){
      d <- data.frame(z=z, t=t)
      tmp <- gam::gam(z ~ gam::lo(t), data=d)
      p <- summary(tmp)[4][[1]][1,5]
      p
    })
    topgenes <- names(sort(gam.pval, decreasing = FALSE))[1:100]
} else {
    topgenes <- heatmapGeneVec
}

topgenes <- topgenes[topgenes %in% row.names(OsC_branch1)]

# Identify genes with the most significant time-dependent model fit.




# Prepare and plot a heatmap of the top genes that vary their expression over pseudotime.
#require(clusterExperiment)



## Get cells in pseudotime order ##
dfOrder <- data.frame(OsC_branch1@meta.data)
dfOrder <- dfOrder[,c("cellID", pseudotimeLineageName, "clusterName")]
dfOrder <- dfOrder[order(dfOrder[,pseudotimeLineageName], decreasing = F),]
cellOrder <- dfOrder$cellID
cellCluster <- dfOrder$clusterName

dfDat <- OsC_branch1@assays$RNA@scale.data
dfDat <- dfDat[topgenes,cellOrder]

PTcol <- names(dfOrder)[grep("Pseudotime", names(dfOrder))]
dfOrder <- dfOrder[,c("cellID", PTcol, "clusterName")]
dfOrder <- dfOrder[order(dfOrder[,PTcol], decreasing = F),]


cellOrder <- as.character(dfOrder$cellID)
cellCluster <- as.character(dfOrder$clusterName)
PTorder <- dfOrder[,PTcol]
names(PTorder) <- dfOrder$cellID
names(dfOrder) <- gsub(PTcol, "Pseudotime", names(dfOrder))

## Make heatmap

## Average Pseudotime data into 100 bins ##
mHmBase <- data.matrix(dfDat)
            
        if ( nrow(mHmBase) < 110){
            showRowNames <- TRUE
        } else {
            showRowNames <- FALSE
        }
        
        ## Create heatmap plot ##
        #library(ComplexHeatmap)
        #library(circlize)
        f1 = circlize::colorRamp2(seq(-4, 4, length = 3), c("#3060cf", "#fffbbc","#c4463a"))    
    

        ## Create top annotation and colorbars ##
        # from https://www.biostars.org/p/368265/
        # from https://bioconductor.statistik.tu-dortmund.de/packages/3.1/bioc/vignettes/ComplexHeatmap/inst/doc/ComplexHeatmap.html
        
        
        anno <- as.data.frame(colnames(mHmBase))
        colnames(anno) <- "cellID"
        anno$Group <- cellCluster
        
        ## Color sample groups in line with the designated sample group color ##
        
        #library(scales)
        #hue_pal()(2)
        dfSel <- OsC_branch1@meta.data
        row.names(dfSel) <- dfSel$cellID
        dfSel <- dfSel[cellOrder, ]
        df <- unique(data.frame(OsC_branch1@meta.data[,c("clusterName", "clusterColor")]))
        
        GroupVec <- as.vector(df$clusterColor)
        names(GroupVec) <- as.vector(df$clusterName)
        
        
        df2 <- unique(dfSel[,c("cellID","clusterName", "clusterColor")])
        df2 <- na.omit(df2)
        row.names(df2) <- df2$cellID
        df2 <- df2[cellOrder, ]
        ClusterVec <- as.vector(df2[,c("clusterName")])
        df2 <- data.frame(df2[,c("clusterName")])
        names(df2) <- "Cluster"
        
        # df2 <- unique(data.frame(OsC_branch1@meta.data[,c("cellID","clusterName", "clusterColor")]))
        # row.names(df2) <- df2$cellID
        # df2 <- df2[cellOrder, ]
        # df2 <- data.frame(df2[,c("clusterName")])
        # names(df2) <- "Group"
        
        col_fun = circlize::colorRamp2(c(0,  ceiling(max(PTorder))), c("lightgrey", "black"))
        
        # ha = ComplexHeatmap::HeatmapAnnotation(
        #     df = df2, col = list(Group = GroupVec)
        # )
        
        ha = ComplexHeatmap::HeatmapAnnotation(
            Pseudotime = PTorder, 
            Cluster = ClusterVec,
            col = list(
              Pseudotime = col_fun,
              Cluster = GroupVec
            )
        )
    
        ComplexHeatmap::ht_opt(
            legend_border = "black",
            heatmap_border = TRUE,
            annotation_border = TRUE
        )
        
        h1 = ComplexHeatmap::Heatmap(
            mHmBase,
            column_title = gsub(
                    "_", 
                    " ", 
                    paste0("Heatmap_", pseudotimeLineageName)
            ),
            name = pseudotimeLineageName, 
            #row_km = 5,
            col = f1,
           
            show_column_names = F,
            show_row_names = showRowNames,
            border = TRUE,
            cluster_columns = F,
            cluster_rows = clusterRows,
            
            #Dendrogram configurations: columns
            clustering_distance_columns="euclidean",
            clustering_method_columns="complete",
            column_dend_height=unit(10,"mm"),
            
            #Dendrogram configurations: rows
            clustering_distance_rows="euclidean",
            clustering_method_rows="complete",
            row_dend_width=grid::unit(10,"mm"),
            top_annotation = ha,
            show_heatmap_legend = TRUE,
            #row_title = NULL,
            #show_row_dend = FALSE,
            row_names_gp = grid::gpar(fontsize = 5)
        ) 
        
    ComplexHeatmap::ht_opt(RESET = TRUE)
  return(h1) 
}      
   
##  End of function                                                          ##
###############################################################################

# hmGeneVecIV <- c(
#     
# )


hmGeneVecL1 <- c(
    "HES1",
    "CEBPD",
    "ZFP36L2",
    "CLU",
    "KRT15",
    "KRT19",
    "FN1",
    "IFITM3",
    "CCL19",
    "PRRX1",
    "ARID5B",
    "HEY1",
    "ASCL1",
    "CLDN3",
    "CLDN4",
    "CLDN9",
    "CD24",
    "HES6",
    "NHLH1",
    "CFAP298",
    "GNG8",
    "STMN1",
    "KIF19",
    "METRN",
    "CIB2",
    "BEX1",
    "NEUROD1",
    "SOX4",
    "SOX2",
    "CHRNA1",
    "LSAMP",
    "SMIM18",
    "MYO6",
    "IRX2",
    "MYO15A",
    "ABCA5",
    "KCNH6",
    "CCER2",
    "POU4F3",
    "PCP4",
    "PKIB",
    "ATOH1",
    "TJAP1",
    "GRXCR1",
    "RBM24",
    "TMPRSS3",
    "USH2A",
    "PAX2",
    "STRC",
    "OTOF",
    "GRXCR2",
    "TRIM36",
    "RSPH1",
    "CD164L2",
    "CRIP3",
    "FAM183A",
    "C1orf194",
    "C1orf232",
    "MINDY4B",
    "CCDC81",
    "C2orf40",
    "SMPX"
)

hmGeneVecL2 <- c(
    "KRT15",
    "KRT19",
    "PRRX1",
    "ARID5B",
    "FN1",
    "IFITM3",
    "HES1",
    "CEBPD",
    "ZFP36L2",
    "CLU",
    "S100A14",
    "CSTB",
    "PLTP",
    "CTSV",
    "SCX",
    "LY75",
    "PRSS16",
    "TBATA",
    "CCL25",
    "GNG11",
    "PSMB11"
)

hmGeneVecL3 <- c(
    "HES1",
    "CEBPD",
    "ZFP36L2",
    "CLU",
    "KRT15",
    "KRT19",
    "FN1",
    "IFITM3",
    "CCL19",
    "PRRX1",
    "ARID5B",
    "HEY1",
    "ASCL1",
    "CLDN3",
    "CLDN4",
    "CLDN9",
    "CD24",
    "EpCAM",
    "HES6",
    "NELL1",
    "UCP2",
    "FNDC5",
    "ZEB2",
    "CKB",
    "FRMD3",
    "MEGF10",
    "RBP1",
    "NNAT",
    "DBN1",
    "MYOG",
    "KLHL41",
    "TPM2",
    "MYL4",
    "ACTC1",
    "MYH3",
    "TNNT3",
    "TNNT2",
    "TNNT1",
    "ACTA1",
    "NES",
    "NEXN",
    "TTN",
    "MEF2C",
    "MEG3",
    "ARPP21",
    "LRRN1",
    "HSPB3",
    "MYLPF",
    "TNNC1"
)

###############################################################################
## 
hm1 <- createLineageHeatmap(
  OsC,  
  lineageSelection = branch1,
  pseudotimeLineageName = "Pseudotime_MC_Lineage_1",
  heatmapGeneVec = hmGeneVecL1,
  clusterRows = FALSE
)
 
pdf("../temp.monocle.lineage1.custom.genes.20210930.pdf")
    hm1
dev.off()

hm2 <- createLineageHeatmap(
  OsC,  
  lineageSelection = branch2,
  pseudotimeLineageName = "Pseudotime_MC_Lineage_2",
  heatmapGeneVec = hmGeneVecL2,
  clusterRows = FALSE
)
 
pdf("../temp.monocle.lineage2.custom.genes.20210930.pdf")
    hm2
dev.off()

hm3 <- createLineageHeatmap(
  OsC,  
  lineageSelection = branch3,
  pseudotimeLineageName = "Pseudotime_MC_Lineage_3",
  heatmapGeneVec = hmGeneVecL3,
  clusterRows = FALSE
)
 
pdf("../temp.monocle.lineage3.custom.genes.20210930.pdf")
    hm3
dev.off()
    
    link <- paste0("https://biologic.crick.ac.uk/",Obio@parameterList$project_id,"/category-view/",Obio@parameterList$HmDisplayCatsFromDb[[k]])
    
    ###########################################################################
    ## Save plot to file                                                     ##
    FNbase <- paste0("Heatmap.", names(Obio@parameterList$HmDisplayCatsFromDb)[k],VersionPdfExt)
    FN <- paste0(Obio@parameterList$reportFigDir, FNbase)
    FNrel <- paste0("report_figures/", FNbase)
    
    pdf(FN)
        print(HMplotList[[names(Obio@parameterList$HmDisplayCatsFromDb)[k]]])
    dev.off()
    ##                                                                       ##
    ###########################################################################
    
    figCap <- paste0(
    "**Figure ",
    figureCount,
    ":** Heatmap showing the gene category ", gsub("_", " ", names(Obio@parameterList$HmDisplayCatsFromDb)[k]), ". ",
        "Download a pdf of this figure [here](", FNrel, "). ",
        "An interactive version of this heatmap with an option for further filtering can be found [here](", link, ")."
    )
    
    figureCount <- figureCount + 1 
    
    NewChnk <- paste0(
            "### HM_", names(Obio@parameterList$HmDisplayCatsFromDb)[k],
            "\n```{r Heatmap_HM_",k,", results='asis', echo=F, eval=TRUE, warning=FALSE, fig.cap='",figCap,"'}\n",
            "\n",
            "\n print(HMplotList[['",names(Obio@parameterList$HmDisplayCatsFromDb)[k],"']])",
            "\n cat(  '\n')",
            "\n\n\n```\n"   
    )
    
    chnkVec <- c(
        chnkVec,
        NewChnk
    )


## Done
######################


## Done                                                                      ##
###############################################################################



###############################################################################
## Helper                                                                    ##
#' Orders cells according to pseudotime.
#'
#' Assigns cells a pseudotime value based on their projection on the principal
#' graph learned in the \code{learn_graph} function and the position of chosen
#' root states. This function takes as input a cell_data_set and returns it
#' with pseudotime information stored internally.
#' \code{order_cells()} optionally takes "root" state(s) in the form of cell
#' or principal graph node IDs, which you can use to specify the start of the
#' trajectory. If you don't provide a root state, an plot will be generated
#' where you can choose the root state(s) interactively. The trajectory will be
#' composed of segments.
#'
#' @param cds the cell_data_set upon which to perform this operation
#' @param reduction_method a string specifying the reduced dimension method to
#'   use when ordering cells. Currently only "UMAP" is supported.
#' @param root_pr_nodes NULL or a vector of starting principal points. If
#'   provided, pseudotime will start (i.e. be zero) at these graph nodes. You
#'   can find the principal point names by running plot_cells with
#'   label_principal_points = TRUE. Both \code{root_pr_nodes} and
#'   \code{root_cells} cannot be provided.
#' @param root_cells NULL or a vector of starting cells. If provided,
#'   pseudotime will start (i.e. be zero) at these cells. Both
#'   \code{root_pr_nodes} and \code{root_cells} cannot be provided.
#' @param verbose Whether to show running information for order_cells
#'
#' @return an updated cell_data_set object.
#' @export
order_cells <- function(cds,
                        reduction_method = "UMAP",
                        root_pr_nodes=NULL,
                        root_cells=NULL,
                        verbose = FALSE){

  assertthat::assert_that(methods::is(cds, "cell_data_set"))
  assertthat::assert_that(assertthat::are_equal("UMAP", reduction_method),
                          msg = paste("Currently only 'UMAP' is accepted as a",
                                      "reduction_method."))
  assertthat::assert_that(!is.null(reducedDims(cds)[[reduction_method]]),
                          msg = paste0("No dimensionality reduction for ",
                                      reduction_method, " calculated. ",
                                      "Please run reduce_dimension with ",
                                      "reduction_method = ", reduction_method,
                                      ", cluster_cells, and learn_graph ",
                                      "before running order_cells."))
  assertthat::assert_that(!is.null(cds@clusters[[reduction_method]]),
                          msg = paste("No cell clusters for",
                                      reduction_method, "calculated.",
                                      "Please run cluster_cells with",
                                      "reduction_method =", reduction_method,
                                      "and run learn_graph before running",
                                      "order_cells."))
  assertthat::assert_that(!is.null(principal_graph(cds)[[reduction_method]]),
                          msg = paste("No principal graph for",
                                      reduction_method, "calculated.",
                                      "Please run learn_graph with",
                                      "reduction_method =", reduction_method,
                                      "before running order_cells."))
  assertthat::assert_that(
    igraph::vcount(principal_graph(cds)[[reduction_method]]) < 10000,
    msg = paste("principal graph is too large. order_cells doesn't support",
                "more than 10 thousand centroids."))
  if(!is.null(root_pr_nodes)) {
    assertthat::assert_that(
      all(root_pr_nodes %in%
            igraph::V(principal_graph(cds)[[reduction_method]])$name),
      msg = paste("All provided root_pr_nodes must be present in the",
                  "principal graph."))
  }

  if(!is.null(root_cells)) {
    assertthat::assert_that(all(root_cells %in% row.names(colData(cds))),
                            msg = paste("All provided root_cells must be",
                                        "present in the cell data set."))
  }

  if(is.null(root_cells) & is.null(root_pr_nodes)) {
    assertthat::assert_that(interactive(),
                            msg = paste("When not in interactive mode, either",
                                        "root_pr_nodes or root_cells",
                                        "must be provided."))
  }
  assertthat::assert_that(!all(c(!is.null(root_cells),
                                 !is.null(root_pr_nodes))),
                          msg = paste("Please specify either root_pr_nodes",
                                      "or root_cells, not both."))

  if (is.null(root_pr_nodes) & is.null(root_cells)){
    if (interactive()){
      root_pr_nodes <-
        select_trajectory_roots(cds, reduction_method = reduction_method)
      if(length(root_pr_nodes) == 0) {
        stop("No root node was chosen!")
      }
    }
  } else if(!is.null(root_cells)){
    closest_vertex <- cds@principal_graph_aux[[
      reduction_method]]$pr_graph_cell_proj_closest_vertex
    root_pr_nodes <- unique(paste("Y_", closest_vertex[root_cells,], sep=""))
    #principal_graph(cds)[[reduction_method]]
  }

  cds@principal_graph_aux[[reduction_method]]$root_pr_nodes <- root_pr_nodes

  cc_ordering <- extract_general_graph_ordering(cds, root_pr_nodes, verbose,
                                                reduction_method)
  cds@principal_graph_aux[[reduction_method]]$pseudotime <-
    cc_ordering[row.names(colData(cds)), ]$pseudo_time
  names(cds@principal_graph_aux[[reduction_method]]$pseudotime) <-
    row.names(colData(cds))

  cds
}

extract_general_graph_ordering <- function(cds,
                                           root_pr_nodes,
                                           verbose=T,
                                           reduction_method) {
  Z <- t(reducedDims(cds)[[reduction_method]])
  Y <- cds@principal_graph_aux[[reduction_method]]$dp_mst
  pr_graph <- principal_graph(cds)[[reduction_method]]

  parents <- rep(NA, length(igraph::V(pr_graph)))
  states <- rep(NA, length(igraph::V(pr_graph)))

  if(any(is.na(igraph::E(pr_graph)$weight))) {
    igraph::E(pr_graph)$weight <- 1
  }

  # do pseudotime calculation on the cell-wise graph
  # 1. identify nearest cells to the selected principal node
  # 2. build a cell-wise graph for each Louvain group
  # 3. run the distance function to assign pseudotime for each cell
  closest_vertex <- find_nearest_vertex(Y[, root_pr_nodes, drop = F], Z)
  closest_vertex_id <- colnames(cds)[closest_vertex]

  cell_wise_graph <-
    cds@principal_graph_aux[[reduction_method]]$pr_graph_cell_proj_tree
  cell_wise_distances <- igraph::distances(cell_wise_graph,
                                           v = closest_vertex_id)

  if (length(closest_vertex_id) > 1){
    node_names <- colnames(cell_wise_distances)
    pseudotimes <- apply(cell_wise_distances, 2, min)
  }else{
    node_names <- names(cell_wise_distances)
    pseudotimes <- cell_wise_distances
  }

  names(pseudotimes) <- node_names

  ordering_df <- data.frame(sample_name = igraph::V(cell_wise_graph)$name,
                            pseudo_time = as.vector(pseudotimes)
  )
  row.names(ordering_df) <- ordering_df$sample_name
  return(ordering_df)
}

# Select the roots of the principal graph
select_trajectory_roots <- function(cds, x=1, y=2, # nocov start
                                    reduction_method) {
  reduced_dim_coords <- t(cds@principal_graph_aux[[reduction_method]]$dp_mst)

  ica_space_df <- as.data.frame(reduced_dim_coords)
  reduced_dims <- as.data.frame(reducedDims(cds)[[reduction_method]])

  #
  # The line (below in this file) that looks like
  #   plotly::add_markers(data = reduced_dims, x=~V1, y = ~V2, z = ~V3,
  # requires columns names of the form V1, V2, ... but in the case of
  # of reduction_method='PCA', this is not the case, the column names
  # are something like PC1, PC2, ...
  # so I replace the column names here, making the change only locally.
  #
  colnames(reduced_dims)<-vapply(seq_along(colnames(reduced_dims)),function(i){paste0('V',i)},c('a'))

  num_reduced_dim <- ncol(ica_space_df)
  if( num_reduced_dim >= 3 ){
    if( num_reduced_dim > 3 )
    {
      message( reduction_method, ' space has ', num_reduced_dim, ' dimensions but is shown in three.' )
    }
    use_3d=TRUE
  }
  else {
    use_3d=FALSE
  }

#   use_3d <- ncol(ica_space_df) >= 3
#   if (use_3d){
#     colnames(ica_space_df) = c("prin_graph_dim_1", "prin_graph_dim_2",
#                                "prin_graph_dim_3")
#   }
#   else{
#     colnames(ica_space_df) = c("prin_graph_dim_1", "prin_graph_dim_2")
#   }
  #
  # Allow for more than two or three dimensions in the reduced
  # dimension space.
  #
  colnames(ica_space_df) <- vapply(seq_along(ica_space_df),function(i){paste0('prin_graph_dim_',i)},c('a'))

  ica_space_df$sample_name <- row.names(ica_space_df)
  ica_space_df$sample_state <- row.names(ica_space_df)

  dp_mst <- principal_graph(cds)[[reduction_method]]

  if (is.null(dp_mst)){
    stop("You must first call orderCells() before using this function")
  }

  if (use_3d){
    edge_df <- dp_mst %>%
      igraph::as_data_frame() %>%
      dplyr::select_(source = "from", target = "to") %>%
      dplyr::left_join(ica_space_df %>%
                         dplyr::select_(source="sample_name",
                                    source_prin_graph_dim_1="prin_graph_dim_1",
                                    source_prin_graph_dim_2="prin_graph_dim_2",
                                    source_prin_graph_dim_3="prin_graph_dim_3"),
                       by = "source") %>%
      dplyr::left_join(ica_space_df %>%
                         dplyr::select_(target="sample_name",
                                    target_prin_graph_dim_1="prin_graph_dim_1",
                                    target_prin_graph_dim_2="prin_graph_dim_2",
                                    target_prin_graph_dim_3="prin_graph_dim_3"),
                       by = "target")
  }else{
    edge_df <- dp_mst %>%
      igraph::as_data_frame() %>%
      dplyr::select_(source = "from", target = "to") %>%
      dplyr::left_join(ica_space_df %>%
                         dplyr::select_(source="sample_name",
                                    source_prin_graph_dim_1="prin_graph_dim_1",
                                    source_prin_graph_dim_2="prin_graph_dim_2"),
                       by = "source") %>%
      dplyr::left_join(ica_space_df %>%
                         dplyr::select_(target="sample_name",
                                    target_prin_graph_dim_1="prin_graph_dim_1",
                                    target_prin_graph_dim_2="prin_graph_dim_2"),
                       by = "target")
  }

  num_roots <- nrow(ica_space_df)
  sel <- rep(FALSE, nrow(ica_space_df))

  if (use_3d){
    ui <- shiny::fluidPage(
      shiny::titlePanel("Choose your root nodes"),

      # Sidebar layout with input and output definitions ----
      shiny::sidebarLayout(

        # Sidebar panel for inputs ----
        shiny::sidebarPanel(
          # clear button
          shiny::actionButton("reset", "Clear"),
          # done button
          shiny::actionButton("done", "Done"),
          shiny::h3("Instructions:"),
          shiny::tags$ol(
            shiny::tags$li("Click and drag to rotate the plot."),
            shiny::tags$li("Click your desired root nodes to select."),
            shiny::tags$li("Click 'Done'.")
          ),
          shiny::h4("Details:"),
          shiny::tags$ul(
            shiny::tags$li(paste("Root nodes indicate where pseudotime will",
                                 "equal zero")),
            shiny::tags$li("To start over, click 'Clear'"),
            shiny::tags$li(paste("You can also choose/unchoose specific nodes",
                                 "by clicking on them directly"))
          )
        ),

        # Main panel for displaying outputs ----
        shiny::mainPanel(
          plotly::plotlyOutput("plot1", height = "800px")
        )
      )
    )

    server <- function(input, output) {

      vals <- shiny::reactiveValues(
        keeprows = rep(TRUE, nrow(ica_space_df))
      )

      output$plot1 <- plotly::renderPlotly({
        ica_space_df$keep <- FALSE
        ica_space_df[ vals$keeprows,]$keep <- TRUE
        if(sum(!ica_space_df$keep) == 0) {
          cols <- c("black")
        } else {
          cols <- c("red", "black")
        }
        plotly::plot_ly() %>%
          plotly::add_markers(x = ica_space_df$prin_graph_dim_1,
                y = ica_space_df$prin_graph_dim_2,
                z = ica_space_df$prin_graph_dim_3,
                key = ica_space_df$sample_name,
                color = ica_space_df$keep,
                colors = cols, size = 5,
                type = "scatter3d", mode="markers") %>%
          plotly::add_markers(data = reduced_dims, x=~V1, y = ~V2, z = ~V3,
                      color = "rgb(220,220,220)", opacity = 0.25, size = 2) %>%
          plotly::layout(showlegend = FALSE)
      })
      # Toggle points that are clicked
      shiny::observeEvent(plotly::event_data("plotly_click"), {
        d <- plotly::event_data("plotly_click")
        new_keep <- rep(FALSE, nrow(ica_space_df))
        new_keep[which(ica_space_df$sample_name == d$key)] <- TRUE
        vals$keeprows <- xor(vals$keeprows, new_keep)
      })

      # Reset all points
      shiny::observeEvent(input$reset, {
        vals$keeprows <- rep(TRUE, nrow(ica_space_df))
      })

      shiny::observeEvent(input$done, {
        shiny::stopApp(vals$keeprows)
      })

    }
    sel <- shiny::runApp(shiny::shinyApp(ui, server))
  } else {
    ui <- shiny::fluidPage(
      shiny::titlePanel("Choose your root nodes"),

      # Sidebar layout with input and output definitions ----
      shiny::sidebarLayout(

        # Sidebar panel for inputs ----
        shiny::sidebarPanel(
          # done button
          shiny::actionButton("choose_toggle", "Choose/unchoose"),
          # clear button
          shiny::actionButton("reset", "Clear"),
          # done button
          shiny::actionButton("done", "Done"),
          shiny::h3("Instructions:"),
          shiny::tags$ol(
            shiny::tags$li("Highlight nodes by clicking and dragging."),
            shiny::tags$li("Click the 'Choose/unchoose' button."),
            shiny::tags$li(paste("Repeat until you have chosen your desired",
                                 "root nodes.")),
            shiny::tags$li("Click 'Done'.")
          ),
          shiny::h4("Details:"),
          shiny::tags$ul(
            shiny::tags$li(paste("Root nodes indicate where pseudotime will",
                                 "equal zero")),
            shiny::tags$li("To start over, click 'Clear'"),
            shiny::tags$li(paste("You can also choose/unchoose specific nodes",
                                 "by clicking on them directly"))
          )

        ),

        # Main panel for displaying outputs ----
        shiny::mainPanel(
          shiny::plotOutput("plot1", height = 350,
                     click = "plot1_click",
                     brush = shiny::brushOpts(id = "plot1_brush"))
        )
      )
    )

    server <- function(input, output, session) {

      vals <- shiny::reactiveValues(
        keeprows = rep(TRUE, nrow(ica_space_df))
      )

      output$plot1 <- shiny::renderPlot({
        keep    <- ica_space_df[ vals$keeprows, , drop = FALSE]
        exclude <- ica_space_df[!vals$keeprows, , drop = FALSE]

        ggplot(keep, aes(prin_graph_dim_1, prin_graph_dim_2)) +
          geom_point(data = reduced_dims, aes(x=V1, y = V2),
                     size = .5, color = "gray", alpha = .3) +
          geom_point(alpha = .7) +
          geom_point(data = exclude, shape = 21, fill = "red", color = "red") +
          geom_segment(data = edge_df,  aes(x = source_prin_graph_dim_1,
                                            xend = target_prin_graph_dim_1,
                                            y = source_prin_graph_dim_2,
                                            yend = target_prin_graph_dim_2)) +
          labs(x="Component 1", y="Component 2") +
          monocle_theme_opts()
      }, height = function() {
        session$clientData$output_plot1_width
      })

      # Toggle points that are clicked
      shiny::observeEvent(input$plot1_click, {
        res <- shiny::nearPoints(ica_space_df,
                                 xvar = "prin_graph_dim_1",
                                 yvar = "prin_graph_dim_2",
                                 input$plot1_click,
                                 allRows = TRUE)

        vals$keeprows <- xor(vals$keeprows, res$selected_)
      })

      # Toggle points that are brushed, when button is clicked
      shiny::observeEvent(input$choose_toggle, {
        res <- shiny::brushedPoints(ica_space_df, input$plot1_brush,
                                    xvar = "prin_graph_dim_1",
                                    yvar = "prin_graph_dim_2",
                                    allRows = TRUE)

        vals$keeprows <- xor(vals$keeprows, res$selected_)
      })

      # Reset all points
      shiny::observeEvent(input$reset, {
        vals$keeprows <- rep(TRUE, nrow(ica_space_df))
      })

      shiny::observeEvent(input$done, {
        shiny::stopApp(vals$keeprows)
      })

    }
    sel <- shiny::runApp(shiny::shinyApp(ui, server))
  }
  ## return indices of selected points
  as.character(ica_space_df$sample_name[which(!sel)])
} # nocov end

branch_nodes <- function(cds,reduction_method="UMAP"){
  g = principal_graph(cds)[[reduction_method]]
  branch_points <- which(igraph::degree(g) > 2)
  branch_points = branch_points[branch_points %in% root_nodes(cds, reduction_method) == FALSE]
  return(branch_points)
}

leaf_nodes <- function(cds,reduction_method="UMAP"){
  g = principal_graph(cds)[[reduction_method]]
  leaves <- which(igraph::degree(g) == 1)
  leaves = leaves[leaves %in% root_nodes(cds, reduction_method) == FALSE]
  return(leaves)
}

root_nodes <- function(cds, reduction_method="UMAP"){
  g = principal_graph(cds)[[reduction_method]]
  root_pr_nodes <- which(names(igraph::V(g)) %in%
                    cds@principal_graph_aux[[reduction_method]]$root_pr_nodes)
  names(root_pr_nodes) <-
    cds@principal_graph_aux[[reduction_method]]$root_pr_nodes
  return(root_pr_nodes)
}


## Done                                                                      ##
###############################################################################